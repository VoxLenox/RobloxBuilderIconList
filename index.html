<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="title" content="Roblox: Builder Icon List" />
		<meta name="description" content="Automatically generated list of Roblox builder icons" />
		<meta name="keywords" content="roblox, builder icon, roblox builder icon, roblox icon, icon" />
		<meta property="og:type" content="website" />
		<meta property="og:url" content="https://voxlenox.github.io/RobloxBuilderIconList" />
		<meta property="og:site_name" content="Builder Icon List" />
		<meta property="og:title" content="Roblox: Builder Icon List" />
		<meta property="og:description" content="Automatically generated list of Roblox builder icons" />

		<title>Roblox: Builder Icon List</title>

		<link rel="icon" type="image/x-icon" href="favicon.ico">

		<script type="application/ld+json">
			{
				"@context": "https://schema.org",
				"@type": "WebSite",
				"name": "Roblox: Builder Icon List",
				"alternateName": "Builder Icon List",
				"description": "Automatically generated list of Roblox builder icons",
				"url": "https://voxlenox.github.io/RobloxBuilderIconList"
			}
		</script>

		<style>
			* {
				margin: 0;
				padding: 0;
			}

			body {
				background-color: rgb(25, 25, 25);
				font-family: monospace;
				color: white;
			}
			
			#loading-screen {
				position: fixed;
				width: 100%;
				height: 100%;
				display: flex;
				justify-content: center;
				align-items: center;
				flex-direction: column;
				z-index: 2;
			}
			
			#loading-spinner {
				border: 20px solid rgb(45, 45, 45);
				border-top: 20px solid #3498db;
				border-radius: 50%;
				width: 120px;
				aspect-ratio: 1/1;
				animation: loading-spin 1s linear infinite;
			}

			#loading-text {
				margin-top: 25px;
				font-size: 20px;
			}
			
			@keyframes loading-spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}
			
			#list-table {
				width: 100%;
				z-index: 1;
				table-layout: fixed;
			}
			
			#list-table th, #list-table td {
				text-align: center;
				padding: 5px 10px;
			}

			#list-table thead {
				background-color: rgb(60, 60, 60);
			}

			#list-table tbody {
				background-color: rgb(50, 50, 50);
			}

			#list-table tbody tr:nth-child(even) {
				background-color: rgb(40, 40, 40);
			}

			::selection {
				background-color: white;
				color: black;
			}

			::-moz-selection {
				background-color: white;
				color: black;
			}
		</style>
	</head>
	<body>
		<div id="loading-screen">
			<div id="loading-spinner"></div>
			<p id="loading-text"></p>
		</div>
		
		<table id="list-table" cellspacing="3px">
			<thead>
				<tr>
					<th rowspan="2" id="index-header-row">Index</th>
					<th colspan="2">Icon</th>
					<th rowspan="2" style="width: 100%;">Name / Ligature components</th>
					<th rowspan="2">Glyph codepoint</th>
				</tr>
				<tr>
					<th>Normal</th>
					<th>Filled (Bold)</th>
				</tr>
			</thead>
			<tbody id="list-body">
			</tbody>
		</table>
		
		<template id="entry-template">
			<tr>
				<td></td>
				<td style="font-family: BuilderIcons;"></td>
				<td style="font-family: BuilderIcons; font-weight: bold;"></td>
				<td></td>
				<td></td>
			</tr>
		</template>
		
		<script type="text/javascript">
			const loadingScreenElement = document.getElementById("loading-screen");
			const loadingTextElement = document.getElementById("loading-text");
			const listTableElement = document.getElementById("list-table");
			
			let loadingText = "";
			let loadingTextDotCount = 0;
			
			function updateLoadingText() {
				loadingTextElement.textContent = loadingText + ".".repeat(loadingTextDotCount);
			}
			
			setInterval(function() {
				if (++loadingTextDotCount > 3) {
					loadingTextDotCount = 0;
				}
				
				updateLoadingText();
			}, 500);
			
			function setLoadingScreenText(text) {
				if (text) {
					loadingText = text;
					updateLoadingText();
					loadingScreenElement.style.display = "flex";
					listTableElement.style.display = "none";
				} else {
					loadingScreenElement.style.display = "none";
					listTableElement.style.display = "block";
				}
			}

			setLoadingScreenText("Loading library");
		</script>

		<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

		<script type="text/javascript">
			function sleepAsync(time) {
				return new Promise(function(resolve, reject) {
					setTimeout(resolve, time);
				});
			}
			
			async function fetchFontBuffer(url) {
				while (true) {
					try {
						return await (await fetch(url)).arrayBuffer();
					} catch (err) {
						await sleepAsync(1000);
					}
				}
			}
			
			(async function() {
				setLoadingScreenText("Fetching font files");
				
				const baseURL = "https://raw.githubusercontent.com/MaximumADHD/Roblox-Client-Tracker/refs/heads/roblox/LuaPackages/Packages/_Index/BuilderIcons/BuilderIcons/Font/";
				const regularFontBuffer = await fetchFontBuffer(baseURL + "BuilderIcons-Regular.ttf");
				const filledFontBuffer = await fetchFontBuffer(baseURL + "BuilderIcons-Filled.ttf");
				
				setLoadingScreenText("Parsing font files");
				
				document.fonts.add(new FontFace("BuilderIcons", regularFontBuffer, {weight: "normal"}));
				document.fonts.add(new FontFace("BuilderIcons", filledFontBuffer, {weight: "bold"}));

				const regularFontData = opentype.parse(regularFontBuffer);
				const filledFontData = opentype.parse(filledFontBuffer);
				
				const entries = [];

				function scanFont(font) {
					const glyphsData = font.glyphs;

					font.tables?.gsub?.lookups?.forEach(function(lookup) {
						lookup.subtables?.forEach(function(subtable) {
							const coverageGlyphs = subtable.coverage?.glyphs;
							subtable.ligatureSets?.forEach(function(ligatureSet, ligatureSetIndex) {
								ligatureSet.forEach(function(ligatureData) {
									const componentsString = [coverageGlyphs?.[ligatureSetIndex], ...ligatureData.components].map(function(value) {
										return String.fromCodePoint(glyphsData.get(value)?.unicode ?? 0);
									}).join("");
									
									if (!entries.find(function(entryData) {
										return entryData.components == componentsString;
									})) {
										entries.push({
											components: componentsString,
											unicode: glyphsData.get(ligatureData.ligGlyph ?? 0)?.unicode ?? 0
										});
									}
								});
							});
						});
					});

					for (let index = 0; index < glyphsData.length; index++) {
						const glyphData = glyphsData.get(index);
						const glyphName = glyphData?.name;
						const glyphUnicode = glyphData?.unicode;
						const glyphCodepoint = glyphData?.unicodes.find(function(value) {
							return value !== glyphUnicode;
						});
						
						if (!entries.find(function(entryData) {
							return entryData.components == glyphName;
						}) && glyphCodepoint != null) {
							entries.push({
								components: glyphName,
								unicode: glyphCodepoint
							});
						}
					}
				}

				scanFont(regularFontData);
				scanFont(filledFontData);

				const entryTemplateElement = document.getElementById("entry-template");
				const listBodyElement = document.getElementById("list-body");
				
				entries.sort(function(entryA, entryB) {
					return entryA.components.localeCompare(entryB.components);
				});

				entries.forEach(function(entryData, index) {
					const entryElement = entryTemplateElement.content.cloneNode(true);
					const tdElements = entryElement.querySelectorAll("td");
					const unicodeCodepoint = entryData.unicode;
					const unicodeCharacter = String.fromCodePoint(unicodeCodepoint);
				
					tdElements[0].textContent = String(index + 1);
					tdElements[1].textContent = unicodeCharacter;
					tdElements[2].textContent = unicodeCharacter;
					tdElements[3].textContent = entryData.components;
					tdElements[4].textContent = "U+" + unicodeCodepoint.toString(16).toUpperCase();
					
					listBodyElement.appendChild(entryElement);
				});
				
				document.getElementById("index-header-row").textContent = `Index (${entries.length})`;
				setLoadingScreenText(null);
			})();
		</script>
	</body>

</html>

